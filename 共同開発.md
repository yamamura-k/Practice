## チーム開発で使うGit



### リモートリポジトリ

これまで出てきたコマンド等は、全てローカルでの出来事でしたが、チーム開発の際には各チームメンバーに自分の進捗を共有する必要があります。そこで、ローカルでの変更を**リモートリポジトリ**にコピーします。これを**プッシュ**と呼びます。プッシュの対象はブランチ単位です。更新されたリモートリポジトリの内容をローカルに取り込むには、**フェッチ**という機能を使用します。

### ブランチ

コミットを分岐させること。これによって、複数機能の同時開発を行うことが容易になります。

分岐させたものを統合したいときには**merge**を使います。これによって複数のブランチの開発履歴を一つに統合することができます。

### プル

フェッチと、フェッチした内容をローカルリポジトリへマージする機能の両方を実現してくれるのが**プル**です。



## ブランチを用いたチーム開発の流れ

1. #### メインブランチからトピックブランチを作成

   一つのトピックに絞った開発を行う、トピックブランチと、開発の中心であるメインブランチ

2. #### 機能実装を行い、コミット

3. #### 定期的にトピックブランチをリモートリポジトリにプッシュ

   リモートにプッシュした進捗をメンバーに確認してもらうなど(プルリクやコードレビュー)

4. #### 定期的にメインブランチの内容をフェッチしてローカルにマージ

   競合がないかなど確認するため、定期的にメインブランチの内容をプルしておく。

5. #### トピックブランチをメインブランチにマージ

   ひと段落ついたところで、トピックブランチをメインにマージ。マージする前にメインをプルしておくこと。

6. #### リモートリポジトリのメインブランチにプッシュ

   マージ出来たらプッシュ。これで全員が参照可能になります。



### ブランチを作ったりする

+ `git branch`作成済みのブランチ一覧確認

+ `git branch <name>` `name`ブランチを作る
+ `git checkout <name>` `name`ブランチに移動する
+ `git branch -m <new name>` 現在いるブランチの名前を`new name`に変更する
+ `git branch -d <name>`  `name`ブランチを削除する
+ `git branch -D <name>`  `name`ブランチを強制的に削除する



### リモートリポジトリを作ったりする

1. #### 新規プロジェクトを立ち上げる場合について

   + Githubに新規リポジトリを作成
   + `git remote add origin https://github.com/<your-account>/<your-repository>.git`でリモートリポジトリの名前を`origin`に設定する
   + `git push -u origin master`で、`origin`の`master`ブランチに現在のブランチを同期する
   + `git push --set-upstream origin mster`を使うと、現在のローカルブランチを指定したリモートブランチの追跡ブランチとして設定でき、以降は引数を指定せずに`git push`できるようになる
   + `git checkout -b <local> origin/<remote>`で、`origin`の`remote`ブランチの追跡ブランチを`local`という名前でローカルに作成可能

2. #### 既存プロジェクトをもとにローカルをセットアップ

   + `git clone <url>`で既存プロジェクトをローカルへ。

#### リモートの変更をマージする

フェッチした後、`git merge <branch-name>`コマンドを使用する。

`git pull`は一見便利そうだけど、競合とか見落として失敗したときに面倒。

#### 誰がいつ書いたコードか調べる

`git blame <file>`

#### 作業途中でブランチを切り替えたい

`git stash`コミット前の変更を一時保存し、ブランチをクリーンな状態にできる。

`git stash pop`  `stash`した変更を再度取り出せる。元々いたブランチ以外からでも実行できるので注意。

```bash
# 名前つきで保存
git stash save <name>
# 保存されてるスタックのリスト確認
git stash list
# スタックの詳細表示
git stash show
```



## ブランチ設計について

明文化してルール決めとかないと、最後マージするときに面倒になるので、ブランチ設計は計画的に行った方が良い。一例：git-flow (この他にも色々あるらしい)

#### ブランチモデル git-flow

##### メインブランチ

+ masterブランチ
  マージ先：なし
  マージ元：feature, release, hot fix
+ developブランチ
  派生元：なし
  マージ先：なし
  マージ元：feature, release, hot fix

##### サポートブランチ

+ featureブランチ
  派生元：develop
  マージ先：develop
  新規開発機能ごとに作成。つまり複数作ることがある。
+ releaseブランチ
  派生元：develop
  マージ先：develop, master
  次のリリースに必要な機能がdevelopに全て取り込まれたら作成。バグ修正やリリース用メタデータの更新など。master, developへのマージが終了したら削除する。
  マージの際、masterブランチには`git tag <release-name>`によってタグ作成する。
+ hotfixブランチ
  派生元：master
  マージ先：develop, master
  緊急修正のために使用。修正完了後は、masterにマージ→developにマージ→削除の流れ。

Git-flow extensionなるものがあるらしく、git-flow実現に役立つコマンドラインツールが使えるらしい。

`brew install git-flow`で入るそうです。

### マージ戦略

#### fast-forward

マージしたときに新しいコミットが作成されない

#### recursive

マージしたい二つのブランチに共通する子コミットを作成し、それを用いてマージする。二つのブランチで異なる変更が存在するときに有効。デフォルトはこれ。

#### その他

+ Resolve 二つのブランチ間で一つ基点を決め、他方の変更差分を直接適用。
+ octopus 三つ以上のブランチマージに対応
+ Our 現在のブランチのファイルのみを使用。履歴をマージ。
+ Subtree 他のブランチの変更内容をサブツリーとしてマージ。

### GitHubをコマンドラインから使おう。

`brew install gh`で入ります。

#### できること

詳しくは[ここ](https://cli.github.com/manual/)読んで！

+ `gh auth login`指示に従えば自分のGitHubアカウントでログインできる
+ 